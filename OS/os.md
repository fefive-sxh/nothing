# 操作系统八股文

## 1. 进程 线程 协程 

**进程**: 是 *资源分配*  的基本单位， 拥有自己独立的内存空间， 分为 代码段， 数据段 以及 堆栈段

进程一般由程序、数据集合和进程控制块三部分组成

**线程**：独立调度的基本单位， 没有自己独立的内存空间， 使用相同的地址空间共享数据， 线程共享进程的堆和方法区， 

线程由线程ID，当前指令指针， 寄存器和堆栈组成

线程 共享进程的 代码段， 数据集， 堆， 同时， 线程拥有自己的栈和寄存器

**协程**：是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，具有对内核来说不可见的特性。

协程出现的原因： 如果遇到很耗时的I/O行为，则整个系统的吞吐立刻下降，因为这个时候线程一直处于阻塞状态，如果线程很多的时候，会存在很多线程处于空闲状态（等待该线程执行完才能执行），造成了资源应用不彻底。

**协程的特点**：

1. 线程的切换由操作系统负责调度，协程由用户自己进行调度，因此减少了上下文切换，提高了效率。

2. 线程的默认Stack大小是1M，而协程更轻量，接近1K。因此可以在相同的内存中开启更多的协程。

3. 由于在同一个线程上，因此可以避免竞争关系而使用锁。

当出现IO阻塞的时候，由协程的调度器进行调度，通过将数据流立刻yield掉（主动让出），并且记录当前栈上的数据，阻塞完后立刻再通过线程恢复栈，并把阻塞的结果放到这个线程上去跑，这样看上去好像跟写同步代码没有任何差别

由于协程的暂停完全由程序控制，发生在用户态上；而线程的阻塞状态是由操作系统内核来进行切换，发生在内核态上。



### 区别

**进程， 线程的区别**

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多。



## 2. 并发和并行





## 3.进程间通信的方式

1. 管道通信
2. 共享内存
3. 消息队列
4. 套接字



## 4. CPU调度算法

1. 先来先服务
2. 短作业优先
3. 最短剩余时间优先
4. 高相应比优先
5. 时间片轮转
6. 多级反馈队列



## 5. 死锁

### 概念

 并发执行时， 两个及以上的进程由于竞争资源而造成的一种 互相等待的现象

### 原因： 

1. 资源竞争

 	2. 进程推进顺序不当，（有些推进顺序会引起无期限的等待永远不会发生的条件， 从而无法推进， 造成死锁）

### 必要条件

1. 互斥：一次只有一个进程可以使用一个资源
2. 占有并等待： 一个**持有资源**的进程 等待获得额外的资源，该资源被其他进程持有
3. 不可抢占：一个资源只有当持有它的进程完成任务后 才能自由的释放
4. 循环等待： 等待资源的进程之间存在环

### 处理方法

1. 鸵鸟策略： （视而不见）
2. 确保系统永远不会进入死锁状态： 预防死锁， 避免死锁
3. 允许系统进入死锁状态， 然后恢复系统： 死锁检测

#### 死锁的预防

抑制死锁发生的必要条件（互斥， 占有并等待， 不可抢占， 循环等待）

可能出现的副作用：

* 降低设备利用率和吞吐量
* 可能有进程饥饿

#### 死锁避免

1. 允许进程动态申请资源，分配之前 先计算资源分配的安全性
2. 如 安全则分配， 不安全则不分配，进程阻塞等待

银行家算法 可以 死锁避免

#### 死锁的检测和恢复

允许进入死锁状态，然后检测死锁

**死锁发生后， 如何处理？**

1. 人工处理
2. 进程终止
3. 资源抢占



## 内存管理

### 存储层次结构

从上至下：

>寄存器
>
>快速缓存
>
>主存
>
>外存

### 动态申请内存算法

#### 首次适应

#### 最佳适应

#### 最差适应

这种 会产生 碎片



### 分页

#### 特点：

1. 没有外碎片
2. 一个程序不必连续存放
3. 程序全部装入内存







